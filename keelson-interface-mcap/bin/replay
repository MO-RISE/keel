#!/usr/bin/env python3

import json
import time
import atexit
import logging
import pathlib
import warnings
import argparse
from queue import Queue, Empty
from threading import Thread, Event
from typing import Dict, Tuple
from collections import deque

import zenoh
from mcap.reader import make_reader
from mcap.records import Channel, Message


import brefv

logger = logging.getLogger("keelson-replay")

PUBLISHERS: Dict[str, zenoh.Publisher] = {}

def put(channel: Channel, message: Message):
    logger.debug("Preparing message on topic %s", channel.topic)

    publisher = PUBLISHERS[channel.id]
    envelope = brefv.enclose(payload=message.data, enclosed_at=message.publish_time)
    publisher.put(envelope)


def run(session: zenoh.Session, args: argparse.Namespace):

    with args.input.open("rb") as fh:
        reader = make_reader(fh)

        stats = reader.get_summary().statistics
        logger.info("Replaying from: %s", args.input)
        logger.info("...with %s channels", stats.channel_count)
        logger.info("...with %s message", stats.message_count)
        logger.info("...with %s chunks", stats.chunk_count)
        logger.info("...with %s schemas", stats.schema_count)
        logger.info("...first message at %s", stats.message_start_time)
        logger.info("...last message at %s", stats.message_end_time)


        for id, channel in reader.get_summary().channels.items():
            logger.info("Declaring publisher for: %s", channel.topic)
            PUBLISHERS[id] = session.declare_publisher(channel.topic)


        iterator = reader.iter_messages(log_time_order=True)

        # Fetch first one
        try:
            _, channel, message = next(iterator)
        except StopIteration:
            raise RuntimeError("File is empty!")
        
        # Send first envelope and set reference time
        first = message.log_time
        reference_time = time.time_ns()
        put(channel, message)

        for _, channel, message in iterator:

            current = message.log_time

            lag = current - first
            logger.debug("Lagging %s ns", lag)

            delay = time.time_ns() - reference_time
            if delay > 0:
                # time.sleep is not accurate enough for the full duration...
                while (time.time_ns() - reference_time) < lag:
                    time.sleep(10e-9)

            else:
                logger.warning("Negative delay: %s ns", delay)

            logger.debug("Putting to zenoh.")
            put(channel, message)
            


def main():
    parser = argparse.ArgumentParser(
        prog="replay",
        description="A pure python mcap replayer for keelson",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )

    parser.add_argument("--log-level", type=int, default=logging.INFO)

    parser.add_argument(
        "-i",
        "--input",
        type=pathlib.Path,
        required=True,
        help="File path to read recorded data from",
    )

    ## Parse arguments and start doing our thing
    args = parser.parse_args()

    # Setup logger
    logging.basicConfig(
        format="%(asctime)s %(levelname)s %(name)s %(message)s", level=args.log_level
    )
    logging.captureWarnings(True)
    zenoh.init_logger()

    # Put together zenoh session configuration
    conf = zenoh.Config()
    conf.insert_json5(zenoh.config.MODE_KEY, json.dumps("peer"))

    ## Construct session
    logger.info("Opening Zenoh session...")
    session = zenoh.open(conf)

    def _on_exit():
        session.close()

    atexit.register(_on_exit)

    try:
        run(session, args)
    except KeyboardInterrupt:
        logging.info("Closing down on user reuqest... (Ctrl-C)")



if __name__ == "__main__":
    main()
